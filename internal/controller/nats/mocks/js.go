// Code generated by mockery v2.30.1. DO NOT EDIT.

package mocks

import (
	nats "github.com/nats-io/nats.go"
	mock "github.com/stretchr/testify/mock"
)

// JetStreamContext is an autogenerated mock type for the JetStreamContext type
type JetStreamContext struct {
	mock.Mock
}

type JetStreamContext_Expecter struct {
	mock *mock.Mock
}

func (_m *JetStreamContext) EXPECT() *JetStreamContext_Expecter {
	return &JetStreamContext_Expecter{mock: &_m.Mock}
}

// AccountInfo provides a mock function with given fields: opts
func (_m *JetStreamContext) AccountInfo(opts ...nats.JSOpt) (*nats.AccountInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.AccountInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) (*nats.AccountInfo, error)); ok {
		return rf(opts...)
	}
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) *nats.AccountInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.AccountInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(...nats.JSOpt) error); ok {
		r1 = rf(opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_AccountInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountInfo'
type JetStreamContext_AccountInfo_Call struct {
	*mock.Call
}

// AccountInfo is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) AccountInfo(opts ...interface{}) *JetStreamContext_AccountInfo_Call {
	return &JetStreamContext_AccountInfo_Call{Call: _e.mock.On("AccountInfo",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContext_AccountInfo_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContext_AccountInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_AccountInfo_Call) Return(_a0 *nats.AccountInfo, _a1 error) *JetStreamContext_AccountInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_AccountInfo_Call) RunAndReturn(run func(...nats.JSOpt) (*nats.AccountInfo, error)) *JetStreamContext_AccountInfo_Call {
	_c.Call.Return(run)
	return _c
}

// AddConsumer provides a mock function with given fields: stream, cfg, opts
func (_m *JetStreamContext) AddConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)); ok {
		return rf(stream, cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) error); ok {
		r1 = rf(stream, cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_AddConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddConsumer'
type JetStreamContext_AddConsumer_Call struct {
	*mock.Call
}

// AddConsumer is a helper method to define mock.On call
//   - stream string
//   - cfg *nats.ConsumerConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) AddConsumer(stream interface{}, cfg interface{}, opts ...interface{}) *JetStreamContext_AddConsumer_Call {
	return &JetStreamContext_AddConsumer_Call{Call: _e.mock.On("AddConsumer",
		append([]interface{}{stream, cfg}, opts...)...)}
}

func (_c *JetStreamContext_AddConsumer_Call) Run(run func(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt)) *JetStreamContext_AddConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(*nats.ConsumerConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_AddConsumer_Call) Return(_a0 *nats.ConsumerInfo, _a1 error) *JetStreamContext_AddConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_AddConsumer_Call) RunAndReturn(run func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)) *JetStreamContext_AddConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// AddStream provides a mock function with given fields: cfg, opts
func (_m *JetStreamContext) AddStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)); ok {
		return rf(cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.StreamConfig, ...nats.JSOpt) error); ok {
		r1 = rf(cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_AddStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddStream'
type JetStreamContext_AddStream_Call struct {
	*mock.Call
}

// AddStream is a helper method to define mock.On call
//   - cfg *nats.StreamConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) AddStream(cfg interface{}, opts ...interface{}) *JetStreamContext_AddStream_Call {
	return &JetStreamContext_AddStream_Call{Call: _e.mock.On("AddStream",
		append([]interface{}{cfg}, opts...)...)}
}

func (_c *JetStreamContext_AddStream_Call) Run(run func(cfg *nats.StreamConfig, opts ...nats.JSOpt)) *JetStreamContext_AddStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(*nats.StreamConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_AddStream_Call) Return(_a0 *nats.StreamInfo, _a1 error) *JetStreamContext_AddStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_AddStream_Call) RunAndReturn(run func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)) *JetStreamContext_AddStream_Call {
	_c.Call.Return(run)
	return _c
}

// ChanQueueSubscribe provides a mock function with given fields: subj, queue, ch, opts
func (_m *JetStreamContext) ChanQueueSubscribe(subj string, queue string, ch chan *nats.Msg, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, queue, ch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, queue, ch, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, chan *nats.Msg, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, queue, ch, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, chan *nats.Msg, ...nats.SubOpt) error); ok {
		r1 = rf(subj, queue, ch, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_ChanQueueSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChanQueueSubscribe'
type JetStreamContext_ChanQueueSubscribe_Call struct {
	*mock.Call
}

// ChanQueueSubscribe is a helper method to define mock.On call
//   - subj string
//   - queue string
//   - ch chan *nats.Msg
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) ChanQueueSubscribe(subj interface{}, queue interface{}, ch interface{}, opts ...interface{}) *JetStreamContext_ChanQueueSubscribe_Call {
	return &JetStreamContext_ChanQueueSubscribe_Call{Call: _e.mock.On("ChanQueueSubscribe",
		append([]interface{}{subj, queue, ch}, opts...)...)}
}

func (_c *JetStreamContext_ChanQueueSubscribe_Call) Run(run func(subj string, queue string, ch chan *nats.Msg, opts ...nats.SubOpt)) *JetStreamContext_ChanQueueSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(chan *nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ChanQueueSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_ChanQueueSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_ChanQueueSubscribe_Call) RunAndReturn(run func(string, string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_ChanQueueSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// ChanSubscribe provides a mock function with given fields: subj, ch, opts
func (_m *JetStreamContext) ChanSubscribe(subj string, ch chan *nats.Msg, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, ch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, ch, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, chan *nats.Msg, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, ch, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, chan *nats.Msg, ...nats.SubOpt) error); ok {
		r1 = rf(subj, ch, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_ChanSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChanSubscribe'
type JetStreamContext_ChanSubscribe_Call struct {
	*mock.Call
}

// ChanSubscribe is a helper method to define mock.On call
//   - subj string
//   - ch chan *nats.Msg
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) ChanSubscribe(subj interface{}, ch interface{}, opts ...interface{}) *JetStreamContext_ChanSubscribe_Call {
	return &JetStreamContext_ChanSubscribe_Call{Call: _e.mock.On("ChanSubscribe",
		append([]interface{}{subj, ch}, opts...)...)}
}

func (_c *JetStreamContext_ChanSubscribe_Call) Run(run func(subj string, ch chan *nats.Msg, opts ...nats.SubOpt)) *JetStreamContext_ChanSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(chan *nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ChanSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_ChanSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_ChanSubscribe_Call) RunAndReturn(run func(string, chan *nats.Msg, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_ChanSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// ConsumerInfo provides a mock function with given fields: stream, name, opts
func (_m *JetStreamContext) ConsumerInfo(stream string, name string, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) (*nats.ConsumerInfo, error)); ok {
		return rf(stream, name, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, name, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.JSOpt) error); ok {
		r1 = rf(stream, name, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_ConsumerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumerInfo'
type JetStreamContext_ConsumerInfo_Call struct {
	*mock.Call
}

// ConsumerInfo is a helper method to define mock.On call
//   - stream string
//   - name string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) ConsumerInfo(stream interface{}, name interface{}, opts ...interface{}) *JetStreamContext_ConsumerInfo_Call {
	return &JetStreamContext_ConsumerInfo_Call{Call: _e.mock.On("ConsumerInfo",
		append([]interface{}{stream, name}, opts...)...)}
}

func (_c *JetStreamContext_ConsumerInfo_Call) Run(run func(stream string, name string, opts ...nats.JSOpt)) *JetStreamContext_ConsumerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ConsumerInfo_Call) Return(_a0 *nats.ConsumerInfo, _a1 error) *JetStreamContext_ConsumerInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_ConsumerInfo_Call) RunAndReturn(run func(string, string, ...nats.JSOpt) (*nats.ConsumerInfo, error)) *JetStreamContext_ConsumerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ConsumerNames provides a mock function with given fields: stream, opts
func (_m *JetStreamContext) ConsumerNames(stream string, opts ...nats.JSOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan string); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContext_ConsumerNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumerNames'
type JetStreamContext_ConsumerNames_Call struct {
	*mock.Call
}

// ConsumerNames is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) ConsumerNames(stream interface{}, opts ...interface{}) *JetStreamContext_ConsumerNames_Call {
	return &JetStreamContext_ConsumerNames_Call{Call: _e.mock.On("ConsumerNames",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContext_ConsumerNames_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContext_ConsumerNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ConsumerNames_Call) Return(_a0 <-chan string) *JetStreamContext_ConsumerNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_ConsumerNames_Call) RunAndReturn(run func(string, ...nats.JSOpt) <-chan string) *JetStreamContext_ConsumerNames_Call {
	_c.Call.Return(run)
	return _c
}

// Consumers provides a mock function with given fields: stream, opts
func (_m *JetStreamContext) Consumers(stream string, opts ...nats.JSOpt) <-chan *nats.ConsumerInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.ConsumerInfo)
		}
	}

	return r0
}

// JetStreamContext_Consumers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Consumers'
type JetStreamContext_Consumers_Call struct {
	*mock.Call
}

// Consumers is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) Consumers(stream interface{}, opts ...interface{}) *JetStreamContext_Consumers_Call {
	return &JetStreamContext_Consumers_Call{Call: _e.mock.On("Consumers",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContext_Consumers_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContext_Consumers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_Consumers_Call) Return(_a0 <-chan *nats.ConsumerInfo) *JetStreamContext_Consumers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_Consumers_Call) RunAndReturn(run func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo) *JetStreamContext_Consumers_Call {
	_c.Call.Return(run)
	return _c
}

// ConsumersInfo provides a mock function with given fields: stream, opts
func (_m *JetStreamContext) ConsumersInfo(stream string, opts ...nats.JSOpt) <-chan *nats.ConsumerInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.ConsumerInfo)
		}
	}

	return r0
}

// JetStreamContext_ConsumersInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumersInfo'
type JetStreamContext_ConsumersInfo_Call struct {
	*mock.Call
}

// ConsumersInfo is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) ConsumersInfo(stream interface{}, opts ...interface{}) *JetStreamContext_ConsumersInfo_Call {
	return &JetStreamContext_ConsumersInfo_Call{Call: _e.mock.On("ConsumersInfo",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContext_ConsumersInfo_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContext_ConsumersInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ConsumersInfo_Call) Return(_a0 <-chan *nats.ConsumerInfo) *JetStreamContext_ConsumersInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_ConsumersInfo_Call) RunAndReturn(run func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo) *JetStreamContext_ConsumersInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CreateKeyValue provides a mock function with given fields: cfg
func (_m *JetStreamContext) CreateKeyValue(cfg *nats.KeyValueConfig) (nats.KeyValue, error) {
	ret := _m.Called(cfg)

	var r0 nats.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.KeyValueConfig) (nats.KeyValue, error)); ok {
		return rf(cfg)
	}
	if rf, ok := ret.Get(0).(func(*nats.KeyValueConfig) nats.KeyValue); ok {
		r0 = rf(cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.KeyValueConfig) error); ok {
		r1 = rf(cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_CreateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateKeyValue'
type JetStreamContext_CreateKeyValue_Call struct {
	*mock.Call
}

// CreateKeyValue is a helper method to define mock.On call
//   - cfg *nats.KeyValueConfig
func (_e *JetStreamContext_Expecter) CreateKeyValue(cfg interface{}) *JetStreamContext_CreateKeyValue_Call {
	return &JetStreamContext_CreateKeyValue_Call{Call: _e.mock.On("CreateKeyValue", cfg)}
}

func (_c *JetStreamContext_CreateKeyValue_Call) Run(run func(cfg *nats.KeyValueConfig)) *JetStreamContext_CreateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*nats.KeyValueConfig))
	})
	return _c
}

func (_c *JetStreamContext_CreateKeyValue_Call) Return(_a0 nats.KeyValue, _a1 error) *JetStreamContext_CreateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_CreateKeyValue_Call) RunAndReturn(run func(*nats.KeyValueConfig) (nats.KeyValue, error)) *JetStreamContext_CreateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateObjectStore provides a mock function with given fields: cfg
func (_m *JetStreamContext) CreateObjectStore(cfg *nats.ObjectStoreConfig) (nats.ObjectStore, error) {
	ret := _m.Called(cfg)

	var r0 nats.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.ObjectStoreConfig) (nats.ObjectStore, error)); ok {
		return rf(cfg)
	}
	if rf, ok := ret.Get(0).(func(*nats.ObjectStoreConfig) nats.ObjectStore); ok {
		r0 = rf(cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.ObjectStoreConfig) error); ok {
		r1 = rf(cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_CreateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateObjectStore'
type JetStreamContext_CreateObjectStore_Call struct {
	*mock.Call
}

// CreateObjectStore is a helper method to define mock.On call
//   - cfg *nats.ObjectStoreConfig
func (_e *JetStreamContext_Expecter) CreateObjectStore(cfg interface{}) *JetStreamContext_CreateObjectStore_Call {
	return &JetStreamContext_CreateObjectStore_Call{Call: _e.mock.On("CreateObjectStore", cfg)}
}

func (_c *JetStreamContext_CreateObjectStore_Call) Run(run func(cfg *nats.ObjectStoreConfig)) *JetStreamContext_CreateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*nats.ObjectStoreConfig))
	})
	return _c
}

func (_c *JetStreamContext_CreateObjectStore_Call) Return(_a0 nats.ObjectStore, _a1 error) *JetStreamContext_CreateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_CreateObjectStore_Call) RunAndReturn(run func(*nats.ObjectStoreConfig) (nats.ObjectStore, error)) *JetStreamContext_CreateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConsumer provides a mock function with given fields: stream, consumer, opts
func (_m *JetStreamContext) DeleteConsumer(stream string, consumer string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, consumer)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) error); ok {
		r0 = rf(stream, consumer, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_DeleteConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConsumer'
type JetStreamContext_DeleteConsumer_Call struct {
	*mock.Call
}

// DeleteConsumer is a helper method to define mock.On call
//   - stream string
//   - consumer string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) DeleteConsumer(stream interface{}, consumer interface{}, opts ...interface{}) *JetStreamContext_DeleteConsumer_Call {
	return &JetStreamContext_DeleteConsumer_Call{Call: _e.mock.On("DeleteConsumer",
		append([]interface{}{stream, consumer}, opts...)...)}
}

func (_c *JetStreamContext_DeleteConsumer_Call) Run(run func(stream string, consumer string, opts ...nats.JSOpt)) *JetStreamContext_DeleteConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_DeleteConsumer_Call) Return(_a0 error) *JetStreamContext_DeleteConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_DeleteConsumer_Call) RunAndReturn(run func(string, string, ...nats.JSOpt) error) *JetStreamContext_DeleteConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKeyValue provides a mock function with given fields: bucket
func (_m *JetStreamContext) DeleteKeyValue(bucket string) error {
	ret := _m.Called(bucket)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_DeleteKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKeyValue'
type JetStreamContext_DeleteKeyValue_Call struct {
	*mock.Call
}

// DeleteKeyValue is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContext_Expecter) DeleteKeyValue(bucket interface{}) *JetStreamContext_DeleteKeyValue_Call {
	return &JetStreamContext_DeleteKeyValue_Call{Call: _e.mock.On("DeleteKeyValue", bucket)}
}

func (_c *JetStreamContext_DeleteKeyValue_Call) Run(run func(bucket string)) *JetStreamContext_DeleteKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContext_DeleteKeyValue_Call) Return(_a0 error) *JetStreamContext_DeleteKeyValue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_DeleteKeyValue_Call) RunAndReturn(run func(string) error) *JetStreamContext_DeleteKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamContext) DeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) error); ok {
		r0 = rf(name, seq, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_DeleteMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMsg'
type JetStreamContext_DeleteMsg_Call struct {
	*mock.Call
}

// DeleteMsg is a helper method to define mock.On call
//   - name string
//   - seq uint64
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) DeleteMsg(name interface{}, seq interface{}, opts ...interface{}) *JetStreamContext_DeleteMsg_Call {
	return &JetStreamContext_DeleteMsg_Call{Call: _e.mock.On("DeleteMsg",
		append([]interface{}{name, seq}, opts...)...)}
}

func (_c *JetStreamContext_DeleteMsg_Call) Run(run func(name string, seq uint64, opts ...nats.JSOpt)) *JetStreamContext_DeleteMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(uint64), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_DeleteMsg_Call) Return(_a0 error) *JetStreamContext_DeleteMsg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_DeleteMsg_Call) RunAndReturn(run func(string, uint64, ...nats.JSOpt) error) *JetStreamContext_DeleteMsg_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjectStore provides a mock function with given fields: bucket
func (_m *JetStreamContext) DeleteObjectStore(bucket string) error {
	ret := _m.Called(bucket)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_DeleteObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectStore'
type JetStreamContext_DeleteObjectStore_Call struct {
	*mock.Call
}

// DeleteObjectStore is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContext_Expecter) DeleteObjectStore(bucket interface{}) *JetStreamContext_DeleteObjectStore_Call {
	return &JetStreamContext_DeleteObjectStore_Call{Call: _e.mock.On("DeleteObjectStore", bucket)}
}

func (_c *JetStreamContext_DeleteObjectStore_Call) Run(run func(bucket string)) *JetStreamContext_DeleteObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContext_DeleteObjectStore_Call) Return(_a0 error) *JetStreamContext_DeleteObjectStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_DeleteObjectStore_Call) RunAndReturn(run func(string) error) *JetStreamContext_DeleteObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStream provides a mock function with given fields: name, opts
func (_m *JetStreamContext) DeleteStream(name string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) error); ok {
		r0 = rf(name, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_DeleteStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStream'
type JetStreamContext_DeleteStream_Call struct {
	*mock.Call
}

// DeleteStream is a helper method to define mock.On call
//   - name string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) DeleteStream(name interface{}, opts ...interface{}) *JetStreamContext_DeleteStream_Call {
	return &JetStreamContext_DeleteStream_Call{Call: _e.mock.On("DeleteStream",
		append([]interface{}{name}, opts...)...)}
}

func (_c *JetStreamContext_DeleteStream_Call) Run(run func(name string, opts ...nats.JSOpt)) *JetStreamContext_DeleteStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_DeleteStream_Call) Return(_a0 error) *JetStreamContext_DeleteStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_DeleteStream_Call) RunAndReturn(run func(string, ...nats.JSOpt) error) *JetStreamContext_DeleteStream_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastMsg provides a mock function with given fields: name, subject, opts
func (_m *JetStreamContext) GetLastMsg(name string, subject string, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, subject)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.RawStreamMsg
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) (*nats.RawStreamMsg, error)); ok {
		return rf(name, subject, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) *nats.RawStreamMsg); ok {
		r0 = rf(name, subject, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.RawStreamMsg)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.JSOpt) error); ok {
		r1 = rf(name, subject, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_GetLastMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastMsg'
type JetStreamContext_GetLastMsg_Call struct {
	*mock.Call
}

// GetLastMsg is a helper method to define mock.On call
//   - name string
//   - subject string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) GetLastMsg(name interface{}, subject interface{}, opts ...interface{}) *JetStreamContext_GetLastMsg_Call {
	return &JetStreamContext_GetLastMsg_Call{Call: _e.mock.On("GetLastMsg",
		append([]interface{}{name, subject}, opts...)...)}
}

func (_c *JetStreamContext_GetLastMsg_Call) Run(run func(name string, subject string, opts ...nats.JSOpt)) *JetStreamContext_GetLastMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_GetLastMsg_Call) Return(_a0 *nats.RawStreamMsg, _a1 error) *JetStreamContext_GetLastMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_GetLastMsg_Call) RunAndReturn(run func(string, string, ...nats.JSOpt) (*nats.RawStreamMsg, error)) *JetStreamContext_GetLastMsg_Call {
	_c.Call.Return(run)
	return _c
}

// GetMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamContext) GetMsg(name string, seq uint64, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.RawStreamMsg
	var r1 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) (*nats.RawStreamMsg, error)); ok {
		return rf(name, seq, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) *nats.RawStreamMsg); ok {
		r0 = rf(name, seq, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.RawStreamMsg)
		}
	}

	if rf, ok := ret.Get(1).(func(string, uint64, ...nats.JSOpt) error); ok {
		r1 = rf(name, seq, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_GetMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMsg'
type JetStreamContext_GetMsg_Call struct {
	*mock.Call
}

// GetMsg is a helper method to define mock.On call
//   - name string
//   - seq uint64
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) GetMsg(name interface{}, seq interface{}, opts ...interface{}) *JetStreamContext_GetMsg_Call {
	return &JetStreamContext_GetMsg_Call{Call: _e.mock.On("GetMsg",
		append([]interface{}{name, seq}, opts...)...)}
}

func (_c *JetStreamContext_GetMsg_Call) Run(run func(name string, seq uint64, opts ...nats.JSOpt)) *JetStreamContext_GetMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(uint64), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_GetMsg_Call) Return(_a0 *nats.RawStreamMsg, _a1 error) *JetStreamContext_GetMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_GetMsg_Call) RunAndReturn(run func(string, uint64, ...nats.JSOpt) (*nats.RawStreamMsg, error)) *JetStreamContext_GetMsg_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValue provides a mock function with given fields: bucket
func (_m *JetStreamContext) KeyValue(bucket string) (nats.KeyValue, error) {
	ret := _m.Called(bucket)

	var r0 nats.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (nats.KeyValue, error)); ok {
		return rf(bucket)
	}
	if rf, ok := ret.Get(0).(func(string) nats.KeyValue); ok {
		r0 = rf(bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_KeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValue'
type JetStreamContext_KeyValue_Call struct {
	*mock.Call
}

// KeyValue is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContext_Expecter) KeyValue(bucket interface{}) *JetStreamContext_KeyValue_Call {
	return &JetStreamContext_KeyValue_Call{Call: _e.mock.On("KeyValue", bucket)}
}

func (_c *JetStreamContext_KeyValue_Call) Run(run func(bucket string)) *JetStreamContext_KeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContext_KeyValue_Call) Return(_a0 nats.KeyValue, _a1 error) *JetStreamContext_KeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_KeyValue_Call) RunAndReturn(run func(string) (nats.KeyValue, error)) *JetStreamContext_KeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStoreNames provides a mock function with given fields:
func (_m *JetStreamContext) KeyValueStoreNames() <-chan string {
	ret := _m.Called()

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func() <-chan string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContext_KeyValueStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStoreNames'
type JetStreamContext_KeyValueStoreNames_Call struct {
	*mock.Call
}

// KeyValueStoreNames is a helper method to define mock.On call
func (_e *JetStreamContext_Expecter) KeyValueStoreNames() *JetStreamContext_KeyValueStoreNames_Call {
	return &JetStreamContext_KeyValueStoreNames_Call{Call: _e.mock.On("KeyValueStoreNames")}
}

func (_c *JetStreamContext_KeyValueStoreNames_Call) Run(run func()) *JetStreamContext_KeyValueStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContext_KeyValueStoreNames_Call) Return(_a0 <-chan string) *JetStreamContext_KeyValueStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_KeyValueStoreNames_Call) RunAndReturn(run func() <-chan string) *JetStreamContext_KeyValueStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStores provides a mock function with given fields:
func (_m *JetStreamContext) KeyValueStores() <-chan nats.KeyValueStatus {
	ret := _m.Called()

	var r0 <-chan nats.KeyValueStatus
	if rf, ok := ret.Get(0).(func() <-chan nats.KeyValueStatus); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan nats.KeyValueStatus)
		}
	}

	return r0
}

// JetStreamContext_KeyValueStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStores'
type JetStreamContext_KeyValueStores_Call struct {
	*mock.Call
}

// KeyValueStores is a helper method to define mock.On call
func (_e *JetStreamContext_Expecter) KeyValueStores() *JetStreamContext_KeyValueStores_Call {
	return &JetStreamContext_KeyValueStores_Call{Call: _e.mock.On("KeyValueStores")}
}

func (_c *JetStreamContext_KeyValueStores_Call) Run(run func()) *JetStreamContext_KeyValueStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContext_KeyValueStores_Call) Return(_a0 <-chan nats.KeyValueStatus) *JetStreamContext_KeyValueStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_KeyValueStores_Call) RunAndReturn(run func() <-chan nats.KeyValueStatus) *JetStreamContext_KeyValueStores_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStore provides a mock function with given fields: bucket
func (_m *JetStreamContext) ObjectStore(bucket string) (nats.ObjectStore, error) {
	ret := _m.Called(bucket)

	var r0 nats.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (nats.ObjectStore, error)); ok {
		return rf(bucket)
	}
	if rf, ok := ret.Get(0).(func(string) nats.ObjectStore); ok {
		r0 = rf(bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_ObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStore'
type JetStreamContext_ObjectStore_Call struct {
	*mock.Call
}

// ObjectStore is a helper method to define mock.On call
//   - bucket string
func (_e *JetStreamContext_Expecter) ObjectStore(bucket interface{}) *JetStreamContext_ObjectStore_Call {
	return &JetStreamContext_ObjectStore_Call{Call: _e.mock.On("ObjectStore", bucket)}
}

func (_c *JetStreamContext_ObjectStore_Call) Run(run func(bucket string)) *JetStreamContext_ObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JetStreamContext_ObjectStore_Call) Return(_a0 nats.ObjectStore, _a1 error) *JetStreamContext_ObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_ObjectStore_Call) RunAndReturn(run func(string) (nats.ObjectStore, error)) *JetStreamContext_ObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStoreNames provides a mock function with given fields: opts
func (_m *JetStreamContext) ObjectStoreNames(opts ...nats.ObjectOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(...nats.ObjectOpt) <-chan string); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContext_ObjectStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStoreNames'
type JetStreamContext_ObjectStoreNames_Call struct {
	*mock.Call
}

// ObjectStoreNames is a helper method to define mock.On call
//   - opts ...nats.ObjectOpt
func (_e *JetStreamContext_Expecter) ObjectStoreNames(opts ...interface{}) *JetStreamContext_ObjectStoreNames_Call {
	return &JetStreamContext_ObjectStoreNames_Call{Call: _e.mock.On("ObjectStoreNames",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContext_ObjectStoreNames_Call) Run(run func(opts ...nats.ObjectOpt)) *JetStreamContext_ObjectStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.ObjectOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.ObjectOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ObjectStoreNames_Call) Return(_a0 <-chan string) *JetStreamContext_ObjectStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_ObjectStoreNames_Call) RunAndReturn(run func(...nats.ObjectOpt) <-chan string) *JetStreamContext_ObjectStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStores provides a mock function with given fields: opts
func (_m *JetStreamContext) ObjectStores(opts ...nats.ObjectOpt) <-chan nats.ObjectStoreStatus {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan nats.ObjectStoreStatus
	if rf, ok := ret.Get(0).(func(...nats.ObjectOpt) <-chan nats.ObjectStoreStatus); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan nats.ObjectStoreStatus)
		}
	}

	return r0
}

// JetStreamContext_ObjectStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStores'
type JetStreamContext_ObjectStores_Call struct {
	*mock.Call
}

// ObjectStores is a helper method to define mock.On call
//   - opts ...nats.ObjectOpt
func (_e *JetStreamContext_Expecter) ObjectStores(opts ...interface{}) *JetStreamContext_ObjectStores_Call {
	return &JetStreamContext_ObjectStores_Call{Call: _e.mock.On("ObjectStores",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContext_ObjectStores_Call) Run(run func(opts ...nats.ObjectOpt)) *JetStreamContext_ObjectStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.ObjectOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.ObjectOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_ObjectStores_Call) Return(_a0 <-chan nats.ObjectStoreStatus) *JetStreamContext_ObjectStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_ObjectStores_Call) RunAndReturn(run func(...nats.ObjectOpt) <-chan nats.ObjectStoreStatus) *JetStreamContext_ObjectStores_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: subj, data, opts
func (_m *JetStreamContext) Publish(subj string, data []byte, opts ...nats.PubOpt) (*nats.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) (*nats.PubAck, error)); ok {
		return rf(subj, data, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) *nats.PubAck); ok {
		r0 = rf(subj, data, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...nats.PubOpt) error); ok {
		r1 = rf(subj, data, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type JetStreamContext_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - subj string
//   - data []byte
//   - opts ...nats.PubOpt
func (_e *JetStreamContext_Expecter) Publish(subj interface{}, data interface{}, opts ...interface{}) *JetStreamContext_Publish_Call {
	return &JetStreamContext_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{subj, data}, opts...)...)}
}

func (_c *JetStreamContext_Publish_Call) Run(run func(subj string, data []byte, opts ...nats.PubOpt)) *JetStreamContext_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_Publish_Call) Return(_a0 *nats.PubAck, _a1 error) *JetStreamContext_Publish_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_Publish_Call) RunAndReturn(run func(string, []byte, ...nats.PubOpt) (*nats.PubAck, error)) *JetStreamContext_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsync provides a mock function with given fields: subj, data, opts
func (_m *JetStreamContext) PublishAsync(subj string, data []byte, opts ...nats.PubOpt) (nats.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 nats.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) (nats.PubAckFuture, error)); ok {
		return rf(subj, data, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...nats.PubOpt) nats.PubAckFuture); ok {
		r0 = rf(subj, data, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...nats.PubOpt) error); ok {
		r1 = rf(subj, data, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_PublishAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsync'
type JetStreamContext_PublishAsync_Call struct {
	*mock.Call
}

// PublishAsync is a helper method to define mock.On call
//   - subj string
//   - data []byte
//   - opts ...nats.PubOpt
func (_e *JetStreamContext_Expecter) PublishAsync(subj interface{}, data interface{}, opts ...interface{}) *JetStreamContext_PublishAsync_Call {
	return &JetStreamContext_PublishAsync_Call{Call: _e.mock.On("PublishAsync",
		append([]interface{}{subj, data}, opts...)...)}
}

func (_c *JetStreamContext_PublishAsync_Call) Run(run func(subj string, data []byte, opts ...nats.PubOpt)) *JetStreamContext_PublishAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_PublishAsync_Call) Return(_a0 nats.PubAckFuture, _a1 error) *JetStreamContext_PublishAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_PublishAsync_Call) RunAndReturn(run func(string, []byte, ...nats.PubOpt) (nats.PubAckFuture, error)) *JetStreamContext_PublishAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncComplete provides a mock function with given fields:
func (_m *JetStreamContext) PublishAsyncComplete() <-chan struct{} {
	ret := _m.Called()

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// JetStreamContext_PublishAsyncComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncComplete'
type JetStreamContext_PublishAsyncComplete_Call struct {
	*mock.Call
}

// PublishAsyncComplete is a helper method to define mock.On call
func (_e *JetStreamContext_Expecter) PublishAsyncComplete() *JetStreamContext_PublishAsyncComplete_Call {
	return &JetStreamContext_PublishAsyncComplete_Call{Call: _e.mock.On("PublishAsyncComplete")}
}

func (_c *JetStreamContext_PublishAsyncComplete_Call) Run(run func()) *JetStreamContext_PublishAsyncComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContext_PublishAsyncComplete_Call) Return(_a0 <-chan struct{}) *JetStreamContext_PublishAsyncComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_PublishAsyncComplete_Call) RunAndReturn(run func() <-chan struct{}) *JetStreamContext_PublishAsyncComplete_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncPending provides a mock function with given fields:
func (_m *JetStreamContext) PublishAsyncPending() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// JetStreamContext_PublishAsyncPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncPending'
type JetStreamContext_PublishAsyncPending_Call struct {
	*mock.Call
}

// PublishAsyncPending is a helper method to define mock.On call
func (_e *JetStreamContext_Expecter) PublishAsyncPending() *JetStreamContext_PublishAsyncPending_Call {
	return &JetStreamContext_PublishAsyncPending_Call{Call: _e.mock.On("PublishAsyncPending")}
}

func (_c *JetStreamContext_PublishAsyncPending_Call) Run(run func()) *JetStreamContext_PublishAsyncPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStreamContext_PublishAsyncPending_Call) Return(_a0 int) *JetStreamContext_PublishAsyncPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_PublishAsyncPending_Call) RunAndReturn(run func() int) *JetStreamContext_PublishAsyncPending_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsg provides a mock function with given fields: m, opts
func (_m *JetStreamContext) PublishMsg(m *nats.Msg, opts ...nats.PubOpt) (*nats.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, m)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) (*nats.PubAck, error)); ok {
		return rf(m, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) *nats.PubAck); ok {
		r0 = rf(m, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...nats.PubOpt) error); ok {
		r1 = rf(m, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_PublishMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsg'
type JetStreamContext_PublishMsg_Call struct {
	*mock.Call
}

// PublishMsg is a helper method to define mock.On call
//   - m *nats.Msg
//   - opts ...nats.PubOpt
func (_e *JetStreamContext_Expecter) PublishMsg(m interface{}, opts ...interface{}) *JetStreamContext_PublishMsg_Call {
	return &JetStreamContext_PublishMsg_Call{Call: _e.mock.On("PublishMsg",
		append([]interface{}{m}, opts...)...)}
}

func (_c *JetStreamContext_PublishMsg_Call) Run(run func(m *nats.Msg, opts ...nats.PubOpt)) *JetStreamContext_PublishMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_PublishMsg_Call) Return(_a0 *nats.PubAck, _a1 error) *JetStreamContext_PublishMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_PublishMsg_Call) RunAndReturn(run func(*nats.Msg, ...nats.PubOpt) (*nats.PubAck, error)) *JetStreamContext_PublishMsg_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsgAsync provides a mock function with given fields: m, opts
func (_m *JetStreamContext) PublishMsgAsync(m *nats.Msg, opts ...nats.PubOpt) (nats.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, m)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 nats.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) (nats.PubAckFuture, error)); ok {
		return rf(m, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...nats.PubOpt) nats.PubAckFuture); ok {
		r0 = rf(m, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nats.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...nats.PubOpt) error); ok {
		r1 = rf(m, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_PublishMsgAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsgAsync'
type JetStreamContext_PublishMsgAsync_Call struct {
	*mock.Call
}

// PublishMsgAsync is a helper method to define mock.On call
//   - m *nats.Msg
//   - opts ...nats.PubOpt
func (_e *JetStreamContext_Expecter) PublishMsgAsync(m interface{}, opts ...interface{}) *JetStreamContext_PublishMsgAsync_Call {
	return &JetStreamContext_PublishMsgAsync_Call{Call: _e.mock.On("PublishMsgAsync",
		append([]interface{}{m}, opts...)...)}
}

func (_c *JetStreamContext_PublishMsgAsync_Call) Run(run func(m *nats.Msg, opts ...nats.PubOpt)) *JetStreamContext_PublishMsgAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.PubOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.PubOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_PublishMsgAsync_Call) Return(_a0 nats.PubAckFuture, _a1 error) *JetStreamContext_PublishMsgAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_PublishMsgAsync_Call) RunAndReturn(run func(*nats.Msg, ...nats.PubOpt) (nats.PubAckFuture, error)) *JetStreamContext_PublishMsgAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PullSubscribe provides a mock function with given fields: subj, durable, opts
func (_m *JetStreamContext) PullSubscribe(subj string, durable string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, durable)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, durable, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, durable, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.SubOpt) error); ok {
		r1 = rf(subj, durable, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_PullSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PullSubscribe'
type JetStreamContext_PullSubscribe_Call struct {
	*mock.Call
}

// PullSubscribe is a helper method to define mock.On call
//   - subj string
//   - durable string
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) PullSubscribe(subj interface{}, durable interface{}, opts ...interface{}) *JetStreamContext_PullSubscribe_Call {
	return &JetStreamContext_PullSubscribe_Call{Call: _e.mock.On("PullSubscribe",
		append([]interface{}{subj, durable}, opts...)...)}
}

func (_c *JetStreamContext_PullSubscribe_Call) Run(run func(subj string, durable string, opts ...nats.SubOpt)) *JetStreamContext_PullSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_PullSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_PullSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_PullSubscribe_Call) RunAndReturn(run func(string, string, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_PullSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// PurgeStream provides a mock function with given fields: name, opts
func (_m *JetStreamContext) PurgeStream(name string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) error); ok {
		r0 = rf(name, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_PurgeStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurgeStream'
type JetStreamContext_PurgeStream_Call struct {
	*mock.Call
}

// PurgeStream is a helper method to define mock.On call
//   - name string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) PurgeStream(name interface{}, opts ...interface{}) *JetStreamContext_PurgeStream_Call {
	return &JetStreamContext_PurgeStream_Call{Call: _e.mock.On("PurgeStream",
		append([]interface{}{name}, opts...)...)}
}

func (_c *JetStreamContext_PurgeStream_Call) Run(run func(name string, opts ...nats.JSOpt)) *JetStreamContext_PurgeStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_PurgeStream_Call) Return(_a0 error) *JetStreamContext_PurgeStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_PurgeStream_Call) RunAndReturn(run func(string, ...nats.JSOpt) error) *JetStreamContext_PurgeStream_Call {
	_c.Call.Return(run)
	return _c
}

// QueueSubscribe provides a mock function with given fields: subj, queue, cb, opts
func (_m *JetStreamContext) QueueSubscribe(subj string, queue string, cb nats.MsgHandler, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, queue, cb)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, queue, cb, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, nats.MsgHandler, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, queue, cb, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, nats.MsgHandler, ...nats.SubOpt) error); ok {
		r1 = rf(subj, queue, cb, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_QueueSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueueSubscribe'
type JetStreamContext_QueueSubscribe_Call struct {
	*mock.Call
}

// QueueSubscribe is a helper method to define mock.On call
//   - subj string
//   - queue string
//   - cb nats.MsgHandler
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) QueueSubscribe(subj interface{}, queue interface{}, cb interface{}, opts ...interface{}) *JetStreamContext_QueueSubscribe_Call {
	return &JetStreamContext_QueueSubscribe_Call{Call: _e.mock.On("QueueSubscribe",
		append([]interface{}{subj, queue, cb}, opts...)...)}
}

func (_c *JetStreamContext_QueueSubscribe_Call) Run(run func(subj string, queue string, cb nats.MsgHandler, opts ...nats.SubOpt)) *JetStreamContext_QueueSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), args[2].(nats.MsgHandler), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_QueueSubscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_QueueSubscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_QueueSubscribe_Call) RunAndReturn(run func(string, string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_QueueSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// QueueSubscribeSync provides a mock function with given fields: subj, queue, opts
func (_m *JetStreamContext) QueueSubscribeSync(subj string, queue string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, queue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, queue, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, queue, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...nats.SubOpt) error); ok {
		r1 = rf(subj, queue, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_QueueSubscribeSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueueSubscribeSync'
type JetStreamContext_QueueSubscribeSync_Call struct {
	*mock.Call
}

// QueueSubscribeSync is a helper method to define mock.On call
//   - subj string
//   - queue string
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) QueueSubscribeSync(subj interface{}, queue interface{}, opts ...interface{}) *JetStreamContext_QueueSubscribeSync_Call {
	return &JetStreamContext_QueueSubscribeSync_Call{Call: _e.mock.On("QueueSubscribeSync",
		append([]interface{}{subj, queue}, opts...)...)}
}

func (_c *JetStreamContext_QueueSubscribeSync_Call) Run(run func(subj string, queue string, opts ...nats.SubOpt)) *JetStreamContext_QueueSubscribeSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_QueueSubscribeSync_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_QueueSubscribeSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_QueueSubscribeSync_Call) RunAndReturn(run func(string, string, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_QueueSubscribeSync_Call {
	_c.Call.Return(run)
	return _c
}

// SecureDeleteMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamContext) SecureDeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) error); ok {
		r0 = rf(name, seq, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStreamContext_SecureDeleteMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SecureDeleteMsg'
type JetStreamContext_SecureDeleteMsg_Call struct {
	*mock.Call
}

// SecureDeleteMsg is a helper method to define mock.On call
//   - name string
//   - seq uint64
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) SecureDeleteMsg(name interface{}, seq interface{}, opts ...interface{}) *JetStreamContext_SecureDeleteMsg_Call {
	return &JetStreamContext_SecureDeleteMsg_Call{Call: _e.mock.On("SecureDeleteMsg",
		append([]interface{}{name, seq}, opts...)...)}
}

func (_c *JetStreamContext_SecureDeleteMsg_Call) Run(run func(name string, seq uint64, opts ...nats.JSOpt)) *JetStreamContext_SecureDeleteMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(uint64), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_SecureDeleteMsg_Call) Return(_a0 error) *JetStreamContext_SecureDeleteMsg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_SecureDeleteMsg_Call) RunAndReturn(run func(string, uint64, ...nats.JSOpt) error) *JetStreamContext_SecureDeleteMsg_Call {
	_c.Call.Return(run)
	return _c
}

// StreamInfo provides a mock function with given fields: stream, opts
func (_m *JetStreamContext) StreamInfo(stream string, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) (*nats.StreamInfo, error)); ok {
		return rf(stream, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...nats.JSOpt) error); ok {
		r1 = rf(stream, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_StreamInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamInfo'
type JetStreamContext_StreamInfo_Call struct {
	*mock.Call
}

// StreamInfo is a helper method to define mock.On call
//   - stream string
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) StreamInfo(stream interface{}, opts ...interface{}) *JetStreamContext_StreamInfo_Call {
	return &JetStreamContext_StreamInfo_Call{Call: _e.mock.On("StreamInfo",
		append([]interface{}{stream}, opts...)...)}
}

func (_c *JetStreamContext_StreamInfo_Call) Run(run func(stream string, opts ...nats.JSOpt)) *JetStreamContext_StreamInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_StreamInfo_Call) Return(_a0 *nats.StreamInfo, _a1 error) *JetStreamContext_StreamInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_StreamInfo_Call) RunAndReturn(run func(string, ...nats.JSOpt) (*nats.StreamInfo, error)) *JetStreamContext_StreamInfo_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNameBySubject provides a mock function with given fields: _a0, _a1
func (_m *JetStreamContext) StreamNameBySubject(_a0 string, _a1 ...nats.JSOpt) (string, error) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) (string, error)); ok {
		return rf(_a0, _a1...)
	}
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) string); ok {
		r0 = rf(_a0, _a1...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, ...nats.JSOpt) error); ok {
		r1 = rf(_a0, _a1...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_StreamNameBySubject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNameBySubject'
type JetStreamContext_StreamNameBySubject_Call struct {
	*mock.Call
}

// StreamNameBySubject is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...nats.JSOpt
func (_e *JetStreamContext_Expecter) StreamNameBySubject(_a0 interface{}, _a1 ...interface{}) *JetStreamContext_StreamNameBySubject_Call {
	return &JetStreamContext_StreamNameBySubject_Call{Call: _e.mock.On("StreamNameBySubject",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *JetStreamContext_StreamNameBySubject_Call) Run(run func(_a0 string, _a1 ...nats.JSOpt)) *JetStreamContext_StreamNameBySubject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_StreamNameBySubject_Call) Return(_a0 string, _a1 error) *JetStreamContext_StreamNameBySubject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_StreamNameBySubject_Call) RunAndReturn(run func(string, ...nats.JSOpt) (string, error)) *JetStreamContext_StreamNameBySubject_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNames provides a mock function with given fields: opts
func (_m *JetStreamContext) StreamNames(opts ...nats.JSOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan string); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// JetStreamContext_StreamNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNames'
type JetStreamContext_StreamNames_Call struct {
	*mock.Call
}

// StreamNames is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) StreamNames(opts ...interface{}) *JetStreamContext_StreamNames_Call {
	return &JetStreamContext_StreamNames_Call{Call: _e.mock.On("StreamNames",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContext_StreamNames_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContext_StreamNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_StreamNames_Call) Return(_a0 <-chan string) *JetStreamContext_StreamNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_StreamNames_Call) RunAndReturn(run func(...nats.JSOpt) <-chan string) *JetStreamContext_StreamNames_Call {
	_c.Call.Return(run)
	return _c
}

// Streams provides a mock function with given fields: opts
func (_m *JetStreamContext) Streams(opts ...nats.JSOpt) <-chan *nats.StreamInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan *nats.StreamInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.StreamInfo)
		}
	}

	return r0
}

// JetStreamContext_Streams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Streams'
type JetStreamContext_Streams_Call struct {
	*mock.Call
}

// Streams is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) Streams(opts ...interface{}) *JetStreamContext_Streams_Call {
	return &JetStreamContext_Streams_Call{Call: _e.mock.On("Streams",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContext_Streams_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContext_Streams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_Streams_Call) Return(_a0 <-chan *nats.StreamInfo) *JetStreamContext_Streams_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_Streams_Call) RunAndReturn(run func(...nats.JSOpt) <-chan *nats.StreamInfo) *JetStreamContext_Streams_Call {
	_c.Call.Return(run)
	return _c
}

// StreamsInfo provides a mock function with given fields: opts
func (_m *JetStreamContext) StreamsInfo(opts ...nats.JSOpt) <-chan *nats.StreamInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan *nats.StreamInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.StreamInfo)
		}
	}

	return r0
}

// JetStreamContext_StreamsInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamsInfo'
type JetStreamContext_StreamsInfo_Call struct {
	*mock.Call
}

// StreamsInfo is a helper method to define mock.On call
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) StreamsInfo(opts ...interface{}) *JetStreamContext_StreamsInfo_Call {
	return &JetStreamContext_StreamsInfo_Call{Call: _e.mock.On("StreamsInfo",
		append([]interface{}{}, opts...)...)}
}

func (_c *JetStreamContext_StreamsInfo_Call) Run(run func(opts ...nats.JSOpt)) *JetStreamContext_StreamsInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_StreamsInfo_Call) Return(_a0 <-chan *nats.StreamInfo) *JetStreamContext_StreamsInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStreamContext_StreamsInfo_Call) RunAndReturn(run func(...nats.JSOpt) <-chan *nats.StreamInfo) *JetStreamContext_StreamsInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: subj, cb, opts
func (_m *JetStreamContext) Subscribe(subj string, cb nats.MsgHandler, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj, cb)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, cb, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, nats.MsgHandler, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, cb, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, nats.MsgHandler, ...nats.SubOpt) error); ok {
		r1 = rf(subj, cb, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type JetStreamContext_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - subj string
//   - cb nats.MsgHandler
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) Subscribe(subj interface{}, cb interface{}, opts ...interface{}) *JetStreamContext_Subscribe_Call {
	return &JetStreamContext_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{subj, cb}, opts...)...)}
}

func (_c *JetStreamContext_Subscribe_Call) Run(run func(subj string, cb nats.MsgHandler, opts ...nats.SubOpt)) *JetStreamContext_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), args[1].(nats.MsgHandler), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_Subscribe_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_Subscribe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_Subscribe_Call) RunAndReturn(run func(string, nats.MsgHandler, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeSync provides a mock function with given fields: subj, opts
func (_m *JetStreamContext) SubscribeSync(subj string, opts ...nats.SubOpt) (*nats.Subscription, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...nats.SubOpt) (*nats.Subscription, error)); ok {
		return rf(subj, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...nats.SubOpt) *nats.Subscription); ok {
		r0 = rf(subj, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...nats.SubOpt) error); ok {
		r1 = rf(subj, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_SubscribeSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeSync'
type JetStreamContext_SubscribeSync_Call struct {
	*mock.Call
}

// SubscribeSync is a helper method to define mock.On call
//   - subj string
//   - opts ...nats.SubOpt
func (_e *JetStreamContext_Expecter) SubscribeSync(subj interface{}, opts ...interface{}) *JetStreamContext_SubscribeSync_Call {
	return &JetStreamContext_SubscribeSync_Call{Call: _e.mock.On("SubscribeSync",
		append([]interface{}{subj}, opts...)...)}
}

func (_c *JetStreamContext_SubscribeSync_Call) Run(run func(subj string, opts ...nats.SubOpt)) *JetStreamContext_SubscribeSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.SubOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.SubOpt)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_SubscribeSync_Call) Return(_a0 *nats.Subscription, _a1 error) *JetStreamContext_SubscribeSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_SubscribeSync_Call) RunAndReturn(run func(string, ...nats.SubOpt) (*nats.Subscription, error)) *JetStreamContext_SubscribeSync_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConsumer provides a mock function with given fields: stream, cfg, opts
func (_m *JetStreamContext) UpdateConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)); ok {
		return rf(stream, cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) error); ok {
		r1 = rf(stream, cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_UpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConsumer'
type JetStreamContext_UpdateConsumer_Call struct {
	*mock.Call
}

// UpdateConsumer is a helper method to define mock.On call
//   - stream string
//   - cfg *nats.ConsumerConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) UpdateConsumer(stream interface{}, cfg interface{}, opts ...interface{}) *JetStreamContext_UpdateConsumer_Call {
	return &JetStreamContext_UpdateConsumer_Call{Call: _e.mock.On("UpdateConsumer",
		append([]interface{}{stream, cfg}, opts...)...)}
}

func (_c *JetStreamContext_UpdateConsumer_Call) Run(run func(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt)) *JetStreamContext_UpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(string), args[1].(*nats.ConsumerConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_UpdateConsumer_Call) Return(_a0 *nats.ConsumerInfo, _a1 error) *JetStreamContext_UpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_UpdateConsumer_Call) RunAndReturn(run func(string, *nats.ConsumerConfig, ...nats.JSOpt) (*nats.ConsumerInfo, error)) *JetStreamContext_UpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStream provides a mock function with given fields: cfg, opts
func (_m *JetStreamContext) UpdateStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)); ok {
		return rf(cfg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.StreamConfig, ...nats.JSOpt) error); ok {
		r1 = rf(cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStreamContext_UpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStream'
type JetStreamContext_UpdateStream_Call struct {
	*mock.Call
}

// UpdateStream is a helper method to define mock.On call
//   - cfg *nats.StreamConfig
//   - opts ...nats.JSOpt
func (_e *JetStreamContext_Expecter) UpdateStream(cfg interface{}, opts ...interface{}) *JetStreamContext_UpdateStream_Call {
	return &JetStreamContext_UpdateStream_Call{Call: _e.mock.On("UpdateStream",
		append([]interface{}{cfg}, opts...)...)}
}

func (_c *JetStreamContext_UpdateStream_Call) Run(run func(cfg *nats.StreamConfig, opts ...nats.JSOpt)) *JetStreamContext_UpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]nats.JSOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(nats.JSOpt)
			}
		}
		run(args[0].(*nats.StreamConfig), variadicArgs...)
	})
	return _c
}

func (_c *JetStreamContext_UpdateStream_Call) Return(_a0 *nats.StreamInfo, _a1 error) *JetStreamContext_UpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStreamContext_UpdateStream_Call) RunAndReturn(run func(*nats.StreamConfig, ...nats.JSOpt) (*nats.StreamInfo, error)) *JetStreamContext_UpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// NewJetStreamContext creates a new instance of JetStreamContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewJetStreamContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *JetStreamContext {
	mock := &JetStreamContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
